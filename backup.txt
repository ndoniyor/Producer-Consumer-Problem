
#include <stdio.h>	     
#include <string.h>
#include <sys/types.h>   
#include <sys/ipc.h>     
#include <sys/shm.h>	 
#include <sys/sem.h>	 
#include <sys/stat.h>
#include <signal.h>
#include <unistd.h>	 
#include <wait.h>	 
#include <time.h>	 
#include <stdlib.h>	 
#include <fcntl.h>
#include <errno.h>

#define SEMAPHORE_ID 250
#define SHARED_MEM_SIZE 2048

union semun {                
    int val;
    struct semid_ds *buffer;
    ushort * array;
};

char* monitor_table;     // stores signals from program for progress tracking

void signal_handler(int signal_no)
{
    static int table_index = 0;
    int c;

    if(signal_no == SIGUSR1)    //signal from producer
        monitor_table[table_index++] = 'P'; //update monitor table
    
    /* Signal is from consumer */
    else if(signal_no == SIGUSR2){  //signal from consumer
        if(table_index > 0){
            if(monitor_table[table_index - 1] == 'C') {
                /* Two consecutive signals from Consumer indicates end. */
                printf("\nMonitor Table Output\n");
                for(c = 0; c < table_index;c++) {
                    printf("%c ", monitor_table[c]);
                }
                printf("C\n");
            }
        }        
        monitor_table[table_index++] = 'C';
    }
    return;
}


int main(int argc, char* argv[])
{
    int semaphore_id, shared_mem_id, result; /* Semaphore ID and Shared memory segment ID */
    char* shared_mem_addr; 	      /* address of shared memory segment.  */
    union semun semaphore_val;    
    ssize_t* bytes_copied;     
    char* buffer;             
    struct shmid_ds shm_desc;
	struct stat st;
    pid_t chpid1, chpid2, pid_main;  /* PID of parent and child processes.  */
    char source_file[255], dest_file[255];

    if(argc >= 3) {
        strcpy(source_file, argv[1]);   /* file input from command line */
        strcpy(dest_file, argv[2]);   /* file output from command line */
    }
    else if(argc == 2) {
        strcpy(source_file, argv[1]);   /* file input from command line */
        strcpy(dest_file, "dest_file");   /* default output file */
    }  
    else {
        printf("Error: no files specified");
        exit(EXIT_FAILURE);
    }

    if (stat(source_file, &st) == -1) {
		perror("stat:");
		exit(EXIT_FAILURE);
	}
    if(st.st_size > 2000000) {
        printf("File size is too big for this process : %ld bytes!\n", st.st_size);
        exit(EXIT_FAILURE);
    }
    monitor_table = (char*)malloc( (st.st_size / 512) + 10);

    /* Create the two user-defined signal handlers */ 
    if( signal( SIGUSR1, signal_handler) == SIG_ERR  )
    {
        perror("main: ");
    }

    if( signal( SIGUSR2, signal_handler) == SIG_ERR  )
    {
        perror("main: ");
    }
  	pid_main = getpid(); /* Get process id of parent */
 
    /* create a semaphore set with one semaphore with owner access only   */
    semaphore_id = semget(SEMAPHORE_ID, 1, IPC_CREAT | 0600);
    if (semaphore_id == -1) {
		perror("main: semget");
		exit(1);
    }

    /* intialize the first semaphore to '1'. */
    semaphore_val.val = 1;
    result = semctl(semaphore_id, 0, SETVAL, semaphore_val);
    if (result == -1) {
		perror("main: semctl");
		exit(1);
    }

    /* allocate a shared memory segment with the predefined size in bytes. */
    shared_mem_id = shmget(100, SHARED_MEM_SIZE, IPC_CREAT | IPC_EXCL | 0600);
    if (shared_mem_id == -1) {
        perror("main: shmget: ");
        exit(1);
    }

    /* attach the shared memory segment to our process's address space. */
    shared_mem_addr = shmat(shared_mem_id, NULL, 0);
    if (!shared_mem_addr) { /* error */
        perror("main: shmat: ");
        exit(1);
    }

    /* Assign address of elements in shared memory space. */
    bytes_copied = (ssize_t*) shared_mem_addr;
    *bytes_copied = 0;
    buffer = (char*) ((void*)shared_mem_addr+sizeof(ssize_t));

    /* fork child processes to trasnfer the file. */
    chpid1 = fork();
    if (chpid1 == 0) {
	    producer(pid_main, semaphore_id, bytes_copied, buffer, source_file);
	    exit(0);
    }
    chpid2 = fork();
    if (chpid2 == 0) {
	    consumer(pid_main, semaphore_id, bytes_copied, buffer, dest_file);
	    exit(0);
    }

    /* wait for child process's termination. */
    {
        int child_status;

        //wait(&child_status);
        //wait(&child_status);
		while( (waitpid(chpid1, &child_status, 0 ) == -1) && (errno == EINTR) ) {}
		while( (waitpid(chpid2, &child_status, 0 ) == -1) && (errno == EINTR) ) {}
    }

    /* detach the shared memory segment from our process's address space. */
    if (shmdt(shared_mem_addr) == -1) {
        perror("main: shmdt: ");
    }

    /* de-allocate the shared memory segment. */
    if (shmctl(shared_mem_id, IPC_RMID, &shm_desc) == -1) {
        perror("main: shmctl: ");
    }

    free(monitor_table);
    return 0;
}